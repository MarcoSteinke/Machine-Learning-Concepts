# Political Parties:

## 1. Introduction:

In this project I want to focus on german parties such as CDU/CSU, SPD, B90/Grüne, FPD, Linke and apply different metrics to find out how different representations of the parties properties are effected 
and which metric may reveal relations, which could be interesting.

The first important aspect is how parties can be represented.

My naive approach would be using two vectors per party. Let the vectors be called â and û. Both vectors are `n-dimensional`, where `n` is the amount of `topics` used to represent all parties. So all vectors will have the same dimension in this model.

## 2. Structure:

### 2.1 Datasets:

The source for this model will be the data from https://parteivergleich.eu/index.php?Wahl=Bundestagswahl_2021_Parteien[this link (parteivergleich.eu)]

### 2.2 Algorithm:

- use vectors and different metrics to perform good in unsupervised learning for the clustering
- transform vectors to train a neural network which shall be able to measure a parties political orientation


## 2.3 Goal:

- build an AI which is able to cluster parties by their topics.
- it shall be able to tell if a party is left, central or right
- let users answer questions to find out about his/her political orientation

## 3. Derivation:

For the actual derivation of the concept I first have to analyze the data presented on parteivergleich.eu!

As already mentioned before I want to use vectors which will be the input to a clustering algorithm and also a neural network and will be used as unlabeled data for the unsupervised clustering algorithm and as labeled data for the neural network at the same time.

So there will be two AI models trained at the same time which together form the complete model for this project.

### 3.1 Dimension of the data:

To find out the dimension of the data I began to do some analysis and formatting of the data, to see what I am dealing with.

Some excerpts of the first overview can be found
https://github.com/MarcoSteinke/Machine-Learning-Concepts/blob/main/implementation/political-parties/parteivergleich.eu-1633706099268.adoc[here]

As a result I first counted each line of the input and it resulted in 88 lines.

In the next step which can be found https://github.com/MarcoSteinke/Machine-Learning-Concepts/blob/main/implementation/political-parties/parteivergleich.eu-1633706099268.adoc#directly-map-tables-into-questions-to-proof-the-amount-88-by-the-amount-of-the-actual-questions-as-strings[here] I decided to try to filter for all questions and again store them in an array, but this time as raw strings and then determine the array's length. This did also result in 88.

The following line shows the query which finally gave me the amount of questions with all questions as strings:

```javascript
[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat().map(row => row.firstElementChild.innerText)
```

Since the parties will be represented by their answers to these questions and will therefore form according vectors, the vectors dimension will be 88!

### 3.2 List of all parties:

The next step is to create a list of all parties for testing purposes and better understanding of the data.

The following slice gives the names of all 36 parties:

```javascript
[...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].map(c => c.innerText).slice(2, [...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].length)

(36) ['AfD', 'berg-\npartei', 'Bayern-\npartei', 'Bündnis\nC', 'BÜNDNIS\n21', 'BüSo', 'CDU*', 'CSU*', 'DiB', 'Die\nGrauen', 'Die\nHumanisten', 'DIE\nLINKE', 'DKP', 'du.\nDie Urbane.', 'FAMILIE', 'FDP', 'FREIE\nWÄHLER', 'Gesundheits-\nforschung', 'Graue\nPanther', 'GRÜNE', 'Klimaliste\nBW', 'LIEBE', 'MENSCHLICHE\nWELT', 'MLPD', 'NPD', 'ÖDP', 'PdF', 'PIRATEN', 'SGP', 'DIE\nSONSTIGEN', 'SPD', 'THP', 'Tierschutz-\nallianz', 'Tierschutz-\npartei', 'UNABHÄNGIGE', 'V-Partei³']
```

Which leads to the result:

```javascript
0: "AfD"
1: "berg-\npartei"
2: "Bayern-\npartei"
3: "Bündnis\nC"
4: "BÜNDNIS\n21"
5: "BüSo"
6: "CDU*"
7: "CSU*"
8: "DiB"
9: "Die\nGrauen"
10: "Die\nHumanisten"
11: "DIE\nLINKE"
12: "DKP"
13: "du.\nDie Urbane."
14: "FAMILIE"
15: "FDP"
16: "FREIE\nWÄHLER"
17: "Gesundheits-\nforschung"
18: "Graue\nPanther"
19: "GRÜNE"
20: "Klimaliste\nBW"
21: "LIEBE"
22: "MENSCHLICHE\nWELT"
23: "MLPD"
24: "NPD"
25: "ÖDP"
26: "PdF"
27: "PIRATEN"
28: "SGP"
29: "DIE\nSONSTIGEN"
30: "SPD"
31: "THP"
32: "Tierschutz-\nallianz"
33: "Tierschutz-\npartei"
34: "UNABHÄNGIGE"
35: "V-Partei³"
```

But as you can see, the names of the parties do include some formatting, which has to be replaced by editing the query!

```javascript
[...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].map(c => c.innerText).slice(2, [...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].length).map(party => party.replace("\n", ""))
```

This results in:

```javascript
0: "AfD"
1: "berg-partei"
2: "Bayern-partei"
3: "BündnisC"
4: "BÜNDNIS21"
5: "BüSo"
6: "CDU*"
7: "CSU*"
8: "DiB"
9: "DieGrauen"
10: "DieHumanisten"
11: "DIELINKE"
12: "DKP"
13: "du.Die Urbane."
14: "FAMILIE"
15: "FDP"
16: "FREIEWÄHLER"
17: "Gesundheits-forschung"
18: "GrauePanther"
19: "GRÜNE"
20: "KlimalisteBW"
21: "LIEBE"
22: "MENSCHLICHEWELT"
23: "MLPD"
24: "NPD"
25: "ÖDP"
26: "PdF"
27: "PIRATEN"
28: "SGP"
29: "DIESONSTIGEN"
30: "SPD"
31: "THP"
32: "Tierschutz-allianz"
33: "Tierschutz-partei"
34: "UNABHÄNGIGE"
35: "V-Partei³"
```

Now there are all parties names with some formatting.

### 3.3 Dataset a.k.a party vectors:

There are 36 parties and each party did answer 88 questions, thus each party will be represented as a vector with 88 elements. Furthermore another question will now come in everybody's head: How to represent the answer of each party?

image::https://github.com/MarcoSteinke/Machine-Learning-Concepts/blob/main/implementation/political-parties/image.png?raw=true[]

As you can see in the image above, questions are being grouped under a title, in this example "Demokratie" which means "Democracy". Parties are allowed to use the following answers for each question:

- Ja (yes)
- Nein (no)
- 0 (neutral or no answer)

The naive approach would be to construct vectors, which only differ between `yes` and `not yes` which would include `no` and `0`.

This would result in vectors only containing 0's and 1's.

Thinking back to the two models which will be trained, it may not be that smart to only use 0's and 1's in the vectors, because this could result in strange results with the chosen metrics for both models. Additionally the political orientation which could be represented on one dimension (left - center - right) could be easily determined by parties giving a `-1` to a question which's approval would put a party on the left side and a `1` for answers which would move a party to the right side.

This would also be a very naive metric and may be optimized in the future. But with this thought, it is not directly clear which elements to choose for the vectors.

For now I only want to construct vectors and all of this thoughts will be relevant to the metric, which can be best chosen after some experiments. So lets try to construct vectors for each party!

The first step to construct vectors is to select a single row and iterate through all rows including questions to find the answers of all parties.

The following snipped will do so:

```javascript
[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat()[0]
```

This gives a row will all cells.

You can simply access the cells with 

```javascript
[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat()[0].cells
```

This will give an HTMLCollection with the content of all cells of the current row:

```javascript
[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat()[0].cells

HTMLCollection(38) [td.bgddd.li.Schr2, td.c, td.bgddd.c, td.bgddd.c, td.bgddd.c, td.c, td.c, td.c, td.bgddd.c, td.bgddd.c, td.bgddd.c, td.c, td.c, td.c, td.bgddd.c, td.bgddd.c, td.bgddd.c, td.c, td.c, td.c, td.bgddd.c, td.bgddd.c, td.bgddd.c, td.c, td.c, td.c, td.bgddd.c, td.bgddd.c, td.bgddd.c, td.c, td.c, td.c, td.bgddd.c, td.bgddd.c, td.bgddd.c, td.c, td.c, td.c]
0: td.bgddd.li.Schr2
1: td.c
2: td.bgddd.c
3: td.bgddd.c
4: td.bgddd.c
5: td.c
6: td.c
7: td.c
8: td.bgddd.c
9: td.bgddd.c
10: td.bgddd.c
11: td.c
12: td.c
13: td.c
14: td.bgddd.c
15: td.bgddd.c
16: td.bgddd.c
17: td.c
18: td.c
19: td.c
20: td.bgddd.c
21: td.bgddd.c
22: td.bgddd.c
23: td.c
24: td.c
25: td.c
26: td.bgddd.c
27: td.bgddd.c
28: td.bgddd.c
29: td.c
30: td.c
31: td.c
32: td.bgddd.c
33: td.bgddd.c
34: td.bgddd.c
35: td.c
36: td.c
37: td.c
length: 38
```

Map each cell to its content and you will see that we could throw away the first two cells:

```javascript
[...[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat()[0].cells].map(c => c.innerText)
(38) ['Soll es verbindliche Volksabstimmungen auf Bundesebene geben?', ' ', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Nein', 'Nein', 'Ja', 'Ja', 'Ja', '0', 'Ja', 'Ja', '0', 'Ja', '0', 'Ja', '0', 'Ja', '0', '0', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja']
```

Because the first cell was the question and the second cell was our personal answer on that website.

This can simply be resolved by another `splice(2)`

```javascript
[...[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat()[0].cells].map(c => c.innerText).splice(2)

(36) ['Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Nein', 'Nein', 'Ja', 'Ja', 'Ja', '0', 'Ja', 'Ja', '0', 'Ja', '0', 'Ja', '0', 'Ja', '0', '0', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja', 'Ja']
```

And now, since all rows can be iterated and each cells value can be read, it is time to construct the vectors by reading the answers of each party!

To iterate all cells from all rows you have to use the following stream:

```javascript
[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat().forEach((row) => {
 [...row.cells].splice(2).forEach(cell => function(cell) {} );
});
```

Where you can exchange `cell => function(cell) {}` by any method which should be called for each cell. In general you know there are 36 parties so you may create a list of all parties and for each cell you would add the value of the cell to the vector of the according party.

So combining some of the already explained queries (streams), you will end up with:

```javascript
let tmpParties = [...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].map(c => c.innerText).slice(2, [...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].length).map(party => party.replace("\n", ""))

(36) ['AfD', 'berg-partei', 'Bayern-partei', 'BündnisC', 'BÜNDNIS21', 'BüSo', 'CDU*', 'CSU*', 'DiB', 'DieGrauen', 'DieHumanisten', 'DIELINKE', 'DKP', 'du.Die Urbane.', 'FAMILIE', 'FDP', 'FREIEWÄHLER', 'Gesundheits-forschung', 'GrauePanther', 'GRÜNE', 'KlimalisteBW', 'LIEBE', 'MENSCHLICHEWELT', 'MLPD', 'NPD', 'ÖDP', 'PdF', 'PIRATEN', 'SGP', 'DIESONSTIGEN', 'SPD', 'THP', 'Tierschutz-allianz', 'Tierschutz-partei', 'UNABHÄNGIGE', 'V-Partei³']

let tmpPartyObjects = [];

tmpParties.forEach(party => { tmpPartyObjects.push({name: party, value: []}) });

tmpPartyObjects

(36) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
0: {name: 'AfD', value: Array(0)}
1: {name: 'berg-partei', value: Array(0)}
2: {name: 'Bayern-partei', value: Array(0)}
3: {name: 'BündnisC', value: Array(0)}
4: {name: 'BÜNDNIS21', value: Array(0)}
5: {name: 'BüSo', value: Array(0)}
6: {name: 'CDU*', value: Array(0)}
7: {name: 'CSU*', value: Array(0)}
8: {name: 'DiB', value: Array(0)}
9: {name: 'DieGrauen', value: Array(0)}
10: {name: 'DieHumanisten', value: Array(0)}
11: {name: 'DIELINKE', value: Array(0)}
12: {name: 'DKP', value: Array(0)}
13: {name: 'du.Die Urbane.', value: Array(0)}
14: {name: 'FAMILIE', value: Array(0)}
15: {name: 'FDP', value: Array(0)}
16: {name: 'FREIEWÄHLER', value: Array(0)}
17: {name: 'Gesundheits-forschung', value: Array(0)}
18: {name: 'GrauePanther', value: Array(0)}
19: {name: 'GRÜNE', value: Array(0)}
20: {name: 'KlimalisteBW', value: Array(0)}
21: {name: 'LIEBE', value: Array(0)}
22: {name: 'MENSCHLICHEWELT', value: Array(0)}
23: {name: 'MLPD', value: Array(0)}
24: {name: 'NPD', value: Array(0)}
25: {name: 'ÖDP', value: Array(0)}
26: {name: 'PdF', value: Array(0)}
27: {name: 'PIRATEN', value: Array(0)}
28: {name: 'SGP', value: Array(0)}
29: {name: 'DIESONSTIGEN', value: Array(0)}
30: {name: 'SPD', value: Array(0)}
31: {name: 'THP', value: Array(0)}
32: {name: 'Tierschutz-allianz', value: Array(0)}
33: {name: 'Tierschutz-partei', value: Array(0)}
34: {name: 'UNABHÄNGIGE', value: Array(0)}
35: {name: 'V-Partei³', value: Array(0)}
length: 36
[[Prototype]]: Array(0)
```

This finally leads to the following code snippet, which constructs vectors for all parties with `1` representing `yes`, `0` representing `no answer` and `-1` representing `no`.

```javascript
let tmpParties = [...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].map(c => c.innerText).slice(2, [...document.querySelector("#aussen > div.rand10px > div:nth-child(9) > table > tbody > tr:nth-child(1)").cells].length).map(party => party.replace("\n", ""))

let tmpPartyObjects = [];
tmpParties.forEach(party => { tmpPartyObjects.push({name: party, value: []}) });

[...[...document.querySelectorAll(".tabscroll")].map(table => [...table.firstElementChild.rows]).map(array => array.splice(1, array.length-2))].flat().forEach((row) => {
 [...row.cells].splice(2).forEach(cell => { 
   if(cell.innerText == 'Ja') { tmpPartyObjects[cell.cellIndex-2].value.push(1); }
   else if(cell.innerText == 'Nein') { tmpPartyObjects[cell.cellIndex-2].value.push(-1); }
   else { tmpPartyObjects[cell.cellIndex-2].value.push(0); }
 } );
});

tmpPartyObjects

(36) [{…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}, {…}]
0: {name: 'AfD', value: Array(88)}
1: {name: 'berg-partei', value: Array(88)}
2: {name: 'Bayern-partei', value: Array(88)}
3: {name: 'BündnisC', value: Array(88)}
4: {name: 'BÜNDNIS21', value: Array(88)}
5: {name: 'BüSo', value: Array(88)}
6: {name: 'CDU*', value: Array(88)}
7: {name: 'CSU*', value: Array(88)}
8: {name: 'DiB', value: Array(88)}
9: {name: 'DieGrauen', value: Array(88)}
10: {name: 'DieHumanisten', value: Array(88)}
11: {name: 'DIELINKE', value: Array(88)}
12: {name: 'DKP', value: Array(88)}
13: {name: 'du.Die Urbane.', value: Array(88)}
14: {name: 'FAMILIE', value: Array(88)}
15: {name: 'FDP', value: Array(88)}
16: {name: 'FREIEWÄHLER', value: Array(88)}
17: {name: 'Gesundheits-forschung', value: Array(88)}
18: {name: 'GrauePanther', value: Array(88)}
19: {name: 'GRÜNE', value: Array(88)}
20: {name: 'KlimalisteBW', value: Array(88)}
21: {name: 'LIEBE', value: Array(88)}
22: {name: 'MENSCHLICHEWELT', value: Array(88)}
23: {name: 'MLPD', value: Array(88)}
24: {name: 'NPD', value: Array(88)}
25: {name: 'ÖDP', value: Array(88)}
26: {name: 'PdF', value: Array(88)}
27: {name: 'PIRATEN', value: Array(88)}
28: {name: 'SGP', value: Array(88)}
29: {name: 'DIESONSTIGEN', value: Array(88)}
30: {name: 'SPD', value: Array(88)}
31: {name: 'THP', value: Array(88)}
32: {name: 'Tierschutz-allianz', value: Array(88)}
33: {name: 'Tierschutz-partei', value: Array(88)}
34: {name: 'UNABHÄNGIGE', value: Array(88)}
35: {name: 'V-Partei³', value: Array(88)}
length: 36
[[Prototype]]: Array(0)
```

As you can see all parties now have vectors of the dimension 88.
## Notes:

- dimension is very high with 88 elements
- maybe summarize questions by category and calculate any kind of value per category.
- No to a very right question could also give a hint on a party being left!
- each question could get combined with a type which will add a multiplicator `1` or `-1` to the answer !
